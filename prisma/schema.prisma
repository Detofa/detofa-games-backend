generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Gender {
  MALE
  FEMALE
}

enum VideoGender {
  MALE
  FEMALE
  BOTH
}

enum Game {
  SNAKE
  FLAPPY_BIRD
  TETRIS
  MATH_DIVISION
}

enum UserStatus {
  USER
  ADMIN
  STAFF
  FILEDTEAM
  SNAKEADMIN
  TETRISADMIN
  FLAPPYBIRDADMIN
}

enum PaymentStatus {
  PENDING
  SUCCESS
  FAILED
  CANCELLED
}

enum PaymentMethod {
  MOBILE_MONEY
  CARD
  CASH
  WALLET
}

model User {
  id                   String                      @id @default(cuid())
  email                String?                     @unique
  password             String?
  name                 String?
  phone                String?                     @unique
  country              String?
  city                 String?
  parent               String?
  imageUrl             String?
  account              Int                         @default(0)
  gender               Gender?
  status               UserStatus                  @default(USER)
  googleId             String?                     @unique
  scores               Score[]
  videos               Video[] // Added this field
  createdAt            DateTime                    @default(now())
  updatedAt            DateTime                    @updatedAt
  VideoView            VideoView[]
  ordersMade           Order[]                     @relation("OrderUser")
  ordersDelivered      Order[]                     @relation("OrderDelivery")
  sentTransactions     Transaction[]               @relation("SentTransactions")
  receivedTransactions Transaction[]               @relation("ReceivedTransactions")
  Cart                 Cart?
  DeliveryAddress      DeliveryAddress[]
  mathAdditionSessions MathAdditionSession[]       @relation("HostedSessions")
  mathAdditionPlayers  MathAdditionSessionPlayer[]
  mathAdditionGuesses  MathAdditionGuess[]
  totalScore           Int                         @default(0)
  MathAdditionSession  MathAdditionSession[]
  notifications        UserNotification[]
  payments             Payment[]
  boughtTickets        BoughtTicket[]
}

model Transaction {
  id         String @id @default(cuid())
  fromUser   User   @relation("SentTransactions", fields: [fromUserId], references: [id])
  fromUserId String

  toUser   User   @relation("ReceivedTransactions", fields: [toUserId], references: [id])
  toUserId String

  amount         Int // Total amount transferred (not including fee)
  transactionFee Int @default(0) // Fee charged for the transaction

  note      String?
  createdAt DateTime @default(now())

  @@index([fromUserId])
  @@index([toUserId])
}

model Score {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  game      Game
  score     Int
  times     Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, game, times, createdAt])
}

model Video {
  id          String       @id @default(uuid())
  user        User         @relation(fields: [userId], references: [id])
  userId      String
  company     String
  type        String
  videoPoint  Int
  vidSource   String
  viewsNumber Int          @default(0)
  viewLimit   Int          @default(10)
  gender      VideoGender?
  ltage       Int?         @default(3) // Less than age limit
  gtage       Int?         @default(100) // Greater than age limit
  town        String?
  country     String?
  product     Product?     @relation(fields: [productId], references: [id])
  productId   String?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  VideoView   VideoView[]

  @@index([userId])
}

model VideoView {
  id       String   @id @default(cuid())
  user     User     @relation(fields: [userId], references: [id])
  userId   String
  video    Video    @relation(fields: [videoId], references: [id])
  videoId  String
  viewedAt DateTime @default(now())

  @@unique([userId, videoId]) // Prevents duplicate views per user unless you want to allow multiple
}

model ProductAvailability {
  id        String  @id @default(cuid())
  product   Product @relation(fields: [productId], references: [id])
  productId String

  city    String
  country String?

  stock     Int      @default(0) // Optional: stock per location
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([productId, city])
}

model Product {
  id          String  @id @default(cuid())
  name        String
  description String?

  price        Float
  pointprice   Int
  stock        Int                   @default(0)
  category     ProductCategory       @relation(fields: [categoryId], references: [id])
  categoryId   String
  images       ProductImage[]
  createdAt    DateTime              @default(now())
  updatedAt    DateTime              @updatedAt
  orders       OrderItem[]
  availability ProductAvailability[]
  Video        Video[]
  CartItem     CartItem[]
}

model ProductCategory {
  id          String    @id @default(cuid())
  name        String    @unique
  description String?
  slug        String    @unique // URL-friendly version of name
  isActive    Boolean   @default(true)
  products    Product[]
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

model ProductImage {
  id        String   @id @default(cuid())
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId String
  imageUrl  String
  altText   String? // Optional alt text for accessibility
  isPrimary Boolean  @default(false) // Flag to mark primary image
  order     Int      @default(0) // For ordering images
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([productId])
  @@index([productId, isPrimary])
}

model Cart {
  id     String @id @default(cuid())
  user   User   @relation(fields: [userId], references: [id])
  userId String

  items     CartItem[]
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  @@unique([userId]) // Each user has one active cart
}

model CartItem {
  id     String @id @default(cuid())
  cart   Cart   @relation(fields: [cartId], references: [id])
  cartId String

  product   Product @relation(fields: [productId], references: [id])
  productId String

  quantity  Int      @default(1)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([cartId, productId]) // Prevent duplicate products in same cart
}

model DeliveryAddress {
  id     String @id @default(cuid())
  user   User   @relation(fields: [userId], references: [id])
  userId String

  label     String? // "Home", "Office", etc.
  address   String
  city      String
  country   String
  latitude  Float?
  longitude Float?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orders Order[]
}

model Order {
  id                String           @id @default(cuid())
  user              User             @relation("OrderUser", fields: [userId], references: [id])
  userId            String
  deliveryGuy       User?            @relation("OrderDelivery", fields: [deliveryGuyId], references: [id])
  deliveryGuyId     String?
  totalAmount       Float
  status            OrderStatus      @default(PENDING)
  receiverName      String
  receiverPhone     String
  deliveryNote      String?
  deliveryAddressId String?
  deliveryAddress   DeliveryAddress? @relation(fields: [deliveryAddressId], references: [id])

  orderItems OrderItem[]
  tracking   LocationTracking?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model OrderItem {
  id        String  @id @default(cuid())
  order     Order   @relation(fields: [orderId], references: [id])
  orderId   String
  product   Product @relation(fields: [productId], references: [id])
  productId String
  quantity  Int
  price     Float
}

model LocationTracking {
  id        String   @id @default(cuid())
  order     Order    @relation(fields: [orderId], references: [id])
  orderId   String   @unique
  latitude  Float
  longitude Float
  updatedAt DateTime @updatedAt
}

enum OrderStatus {
  PENDING
  CONFIRMED
  SHIPPED
  DELIVERED
  CANCELLED
}

model DataDeletionRequest {
  id      String   @id @default(cuid())
  userId  String
  date    DateTime @default(now())
  updated DateTime @updatedAt
}

// --- Math Addition Game Models ---
enum GameMode {
  SOLO
  GROUP
}

enum SessionStatus {
  WAITING
  PLAYING
  ENDED
}

model MathAdditionSession {
  id          String                      @id @default(cuid())
  hostUserId  String
  hostUser    User                        @relation("HostedSessions", fields: [hostUserId], references: [id])
  gameMode    GameMode
  numberCount Int                         @default(10)
  status      SessionStatus               @default(WAITING)
  createdAt   DateTime                    @default(now())
  players     MathAdditionSessionPlayer[]
  numbers     MathAdditionSessionNumber[]
  guesses     MathAdditionGuess[]
  User        User?                       @relation(fields: [userId], references: [id])
  userId      String?
}

model MathAdditionSessionPlayer {
  id         String              @id @default(cuid())
  sessionId  String
  session    MathAdditionSession @relation(fields: [sessionId], references: [id])
  userId     String
  user       User                @relation(fields: [userId], references: [id])
  isHost     Boolean             @default(false)
  joinedAt   DateTime            @default(now())
  eliminated Boolean             @default(false)
  ranking    Int?
}

model MathAdditionSessionNumber {
  id        String              @id @default(cuid())
  sessionId String
  session   MathAdditionSession @relation(fields: [sessionId], references: [id])
  index     Int
  value     Int
}

model MathAdditionGuess {
  id                        String              @id @default(cuid())
  sessionId                 String
  session                   MathAdditionSession @relation(fields: [sessionId], references: [id])
  userId                    String
  user                      User                @relation(fields: [userId], references: [id])
  guessValue                Int
  isCorrect                 Boolean
  submittedAt               DateTime            @default(now())
  distanceFromCorrectAnswer Int
}

model Notification {
  id        String   @id @default(cuid())
  title     String
  body      String
  type      String? // e.g., "INFO", "ALERT", "ORDER", etc.
  createdAt DateTime @default(now())
  updated   DateTime @updatedAt

  // Relations
  recipients UserNotification[]
}

model UserNotification {
  id     String @id @default(cuid())
  user   User   @relation(fields: [userId], references: [id])
  userId String

  notification   Notification @relation(fields: [notificationId], references: [id])
  notificationId String

  isRead     Boolean  @default(false)
  receivedAt DateTime @default(now())
  updated    DateTime @updatedAt

  @@unique([userId, notificationId]) // Prevent duplicate notifications
}

enum AppPlatform {
  IOS
  ANDROID
  WEB
}

enum AppStatus {
  ACTIVE
  INACTIVE
  BETA
}

model App {
  id             String      @id @default(cuid())
  name           String
  platform       AppPlatform
  version        String
  description    String?
  fileUrl        String? // URL to APK/IPA/AAB file (stored in Cloudinary or similar) - now optional
  variants       Json? // Array of variant objects for dynamic delivery (e.g., [{"architecture": "arm64-v8a", "fileUrl": "...", "size": "20 MB"}])
  iconUrl        String? // App icon URL
  previewImages  Json? // Array of preview image URLs (like app store screenshots)
  downloadCount  Int         @default(0) // Total download count
  status         AppStatus   @default(ACTIVE)
  size           String? // File size (e.g., "25.5 MB")
  minVersion     String? // Minimum OS version required (e.g., "iOS 13.0", "Android 8.0")
  releaseNotes   String? // Release notes for this version
  completedSteps Json? // Track which steps are completed: {"step1": true, "step2": false, "step3": false}
  isComplete     Boolean     @default(false) // Whether all steps are completed
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  @@index([platform, status])
  @@index([createdAt])
  @@index([isComplete])
}

model Payment {
  id            String        @id @default(cuid())

  amount        Float         // Amount paid in CDF
  currency      String        @default("CDF")

  method        PaymentMethod
  status        PaymentStatus @default(PENDING)

  reference     String?       // External payment reference (Mobile Money, Stripe, etc.)
  provider      String?       // e.g. "Airtel Money", "M-Pesa", "Orange Money"

  email         String?       // Payer email (optional but useful)

  user          User?         @relation(fields: [userId], references: [id])
  userId        String?

  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  boughtTickets BoughtTicket[]

  @@index([status])
  @@index([userId])
}

enum TicketPurchaseStatus {
  PENDING
  PAID
  CANCELLED
  USED
}

enum TicketStatus {
  ACTIVE
  INACTIVE
  SOLD_OUT
}

model Ticket {
  id            String        @id @default(cuid())
  title         String
  description   String?

  price         Float
  currency      String        @default("CDF")

  totalQuantity Int
  soldQuantity  Int           @default(0)

  eventDate     DateTime?
  location      String?

  status        TicketStatus  @default(ACTIVE)

  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  purchases     BoughtTicket[]
}

model BoughtTicket {
  id          String                @id @default(cuid())

  user        User?                 @relation(fields: [userId], references: [id])
  userId      String?

  email       String                // Mandatory for ticket delivery

  ticket      Ticket                @relation(fields: [ticketId], references: [id])
  ticketId    String

  quantity    Int                   @default(1)
  totalPrice  Float                 // Stored in CDF

  status      TicketPurchaseStatus  @default(PENDING)

  qrCode      String?               // Unique ticket QR value
  usedAt      DateTime?

  payment     Payment?              @relation(fields: [paymentId], references: [id])
  paymentId   String?

  createdAt   DateTime              @default(now())
  updatedAt   DateTime              @updatedAt

  @@index([email])
  @@index([ticketId])
  @@index([paymentId])
}
